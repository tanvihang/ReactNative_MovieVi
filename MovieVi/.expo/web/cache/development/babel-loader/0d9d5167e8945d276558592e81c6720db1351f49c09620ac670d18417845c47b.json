{"ast":null,"code":"import { CommonActions, getActionFromState, StackActions } from \"@react-navigation/core\";\nimport { TabActions } from \"@react-navigation/native\";\nimport * as Linking from \"expo-linking\";\nimport { resolveHref } from \"../link/href\";\nimport { resolve } from \"../link/path\";\nimport { findTopRouteForTarget, getEarliestMismatchedRoute, getQualifiedStateForTopOfTargetState, isMovingToSiblingRoute } from \"../link/stateOperations\";\nimport { hasUrlProtocolPrefix } from \"../utils/url\";\nfunction assertIsReady(store) {\n  if (!store.isReady || !store.navigationRef.current) {\n    throw new Error(\"Attempted to navigate before mounting the Root Layout component. Ensure the Root Layout component is rendering a Slot, or other navigator on the first render.\");\n  }\n}\nexport function push(url) {\n  return this.linkTo(resolveHref(url));\n}\nexport function replace(url) {\n  return this.linkTo(resolveHref(url), \"REPLACE\");\n}\nexport function goBack() {\n  var _this$navigationRef, _this$navigationRef$c;\n  assertIsReady(this);\n  (_this$navigationRef = this.navigationRef) == null ? void 0 : (_this$navigationRef$c = _this$navigationRef.current) == null ? void 0 : _this$navigationRef$c.goBack();\n}\nexport function canGoBack() {\n  var _this$navigationRef$c2, _this$navigationRef2, _this$navigationRef2$;\n  assertIsReady(this);\n  return (_this$navigationRef$c2 = (_this$navigationRef2 = this.navigationRef) == null ? void 0 : (_this$navigationRef2$ = _this$navigationRef2.current) == null ? void 0 : _this$navigationRef2$.canGoBack()) != null ? _this$navigationRef$c2 : false;\n}\nexport function setParams() {\n  var _this$navigationRef3, _this$navigationRef3$;\n  var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  assertIsReady(this);\n  return ((_this$navigationRef3 = this.navigationRef) == null ? void 0 : (_this$navigationRef3$ = _this$navigationRef3.current) == null ? void 0 : _this$navigationRef3$.setParams.bind(_this$navigationRef3$))(params);\n}\nexport function linkTo(href, event) {\n  if (hasUrlProtocolPrefix(href)) {\n    Linking.openURL(href);\n    return;\n  }\n  assertIsReady(this);\n  var navigationRef = this.navigationRef.current;\n  if (navigationRef == null) {\n    throw new Error(\"Couldn't find a navigation object. Is your component inside NavigationContainer?\");\n  }\n  if (!this.linking) {\n    throw new Error(\"Attempted to link to route when no routes are present\");\n  }\n  if (href === \"..\" || href === \"../\") {\n    navigationRef.goBack();\n    return;\n  }\n  if (href.startsWith(\".\")) {\n    var _this$linking$getPath, _this$linking$getPath2, _this$linking;\n    var base = (_this$linking$getPath = (_this$linking$getPath2 = (_this$linking = this.linking).getPathFromState) == null ? void 0 : _this$linking$getPath2.call(_this$linking, navigationRef.getRootState(), {\n      screens: [],\n      preserveGroups: true\n    })) != null ? _this$linking$getPath : \"\";\n    if (base && !base.endsWith(\"/\")) {\n      base += \"/..\";\n    }\n    href = resolve(base, href);\n  }\n  var state = this.linking.getStateFromPath(href, this.linking.config);\n  if (!state) {\n    console.error(\"Could not generate a valid navigation state for the given path: \" + href);\n    return;\n  }\n  var rootState = navigationRef.getRootState();\n  if (isMovingToSiblingRoute(rootState, state)) {\n    var knownOwnerState = getQualifiedStateForTopOfTargetState(rootState, state);\n    var nextRoute = findTopRouteForTarget(state);\n    if (knownOwnerState.type === \"tab\") {\n      if (event === \"REPLACE\") {\n        navigationRef.dispatch(TabActions.jumpTo(nextRoute.name, nextRoute.params));\n      } else {\n        navigationRef.dispatch(CommonActions.navigate(nextRoute.name, nextRoute.params));\n      }\n      return;\n    } else {\n      if (event === \"REPLACE\") {\n        navigationRef.dispatch(StackActions.replace(nextRoute.name, nextRoute.params));\n      } else {\n        navigationRef.dispatch(CommonActions.navigate(nextRoute.name, nextRoute.params));\n      }\n      return;\n    }\n  }\n  var action = getActionFromState(state, this.linking.config);\n  if (action) {\n    if (event === \"REPLACE\" && isAbsoluteInitialRoute(action)) {\n      var earliest = getEarliestMismatchedRoute(rootState, action.payload);\n      if (earliest) {\n        if (earliest.type === \"stack\") {\n          navigationRef.dispatch(StackActions.replace(earliest.name, earliest.params));\n        } else {\n          navigationRef.dispatch(TabActions.jumpTo(earliest.name, earliest.params));\n        }\n        return;\n      } else {}\n    }\n    navigationRef.dispatch(action);\n  } else {\n    navigationRef.reset(state);\n  }\n}\nexport function isAbsoluteInitialRoute(action) {\n  if ((action == null ? void 0 : action.type) !== \"NAVIGATE\") {\n    return false;\n  }\n  var next = action.payload.params;\n  while (next) {\n    if (!isNavigationState(next)) {\n      return false;\n    }\n    if (next.initial === true) {\n      next = next.params;\n    } else if (next.initial === false) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction isNavigationState(obj) {\n  return \"initial\" in obj;\n}","map":{"version":3,"names":["CommonActions","getActionFromState","StackActions","TabActions","Linking","resolveHref","resolve","findTopRouteForTarget","getEarliestMismatchedRoute","getQualifiedStateForTopOfTargetState","isMovingToSiblingRoute","hasUrlProtocolPrefix","assertIsReady","store","isReady","navigationRef","current","Error","push","url","linkTo","replace","goBack","_this$navigationRef","_this$navigationRef$c","canGoBack","_this$navigationRef$c2","_this$navigationRef2","_this$navigationRef2$","setParams","_this$navigationRef3","_this$navigationRef3$","params","arguments","length","undefined","bind","href","event","openURL","linking","startsWith","_this$linking$getPath","_this$linking$getPath2","_this$linking","base","getPathFromState","call","getRootState","screens","preserveGroups","endsWith","state","getStateFromPath","config","console","error","rootState","knownOwnerState","nextRoute","type","dispatch","jumpTo","name","navigate","action","isAbsoluteInitialRoute","earliest","payload","reset","next","isNavigationState","initial","obj"],"sources":["D:/UniversityFile/Year4/ReactNative/Demo/MovieVi/node_modules/expo-router/src/global-state/routing.ts"],"sourcesContent":["import {\n  CommonActions,\n  getActionFromState,\n  StackActions,\n} from \"@react-navigation/core\";\nimport { TabActions } from \"@react-navigation/native\";\nimport * as Linking from \"expo-linking\";\n\nimport { Href, resolveHref } from \"../link/href\";\nimport { resolve } from \"../link/path\";\nimport {\n  NavigateAction,\n  findTopRouteForTarget,\n  getEarliestMismatchedRoute,\n  getQualifiedStateForTopOfTargetState,\n  isMovingToSiblingRoute,\n} from \"../link/stateOperations\";\nimport { hasUrlProtocolPrefix } from \"../utils/url\";\nimport type { RouterStore } from \"./router-store\";\n\nfunction assertIsReady(store: RouterStore) {\n  if (!store.isReady || !store.navigationRef.current) {\n    throw new Error(\n      \"Attempted to navigate before mounting the Root Layout component. Ensure the Root Layout component is rendering a Slot, or other navigator on the first render.\"\n    );\n  }\n}\n\nexport function push(this: RouterStore, url: Href) {\n  return this.linkTo(resolveHref(url));\n}\n\nexport function replace(this: RouterStore, url: Href) {\n  return this.linkTo(resolveHref(url), \"REPLACE\");\n}\n\nexport function goBack(this: RouterStore) {\n  assertIsReady(this);\n  this.navigationRef?.current?.goBack();\n}\n\nexport function canGoBack(this: RouterStore): boolean {\n  assertIsReady(this);\n  return this.navigationRef?.current?.canGoBack() ?? false;\n}\n\nexport function setParams(\n  this: RouterStore,\n  params: Record<string, string | number> = {}\n) {\n  assertIsReady(this);\n  return (this.navigationRef?.current?.setParams as any)(params);\n}\n\nexport function linkTo(this: RouterStore, href: string, event?: string) {\n  if (hasUrlProtocolPrefix(href)) {\n    Linking.openURL(href);\n    return;\n  }\n\n  assertIsReady(this);\n  const navigationRef = this.navigationRef.current;\n\n  if (navigationRef == null) {\n    throw new Error(\n      \"Couldn't find a navigation object. Is your component inside NavigationContainer?\"\n    );\n  }\n\n  if (!this.linking) {\n    throw new Error(\"Attempted to link to route when no routes are present\");\n  }\n\n  if (href === \"..\" || href === \"../\") {\n    navigationRef.goBack();\n    return;\n  }\n\n  if (href.startsWith(\".\")) {\n    let base =\n      this.linking.getPathFromState?.(navigationRef.getRootState(), {\n        screens: [],\n        preserveGroups: true,\n      }) ?? \"\";\n\n    if (base && !base.endsWith(\"/\")) {\n      base += \"/..\";\n    }\n    href = resolve(base, href);\n  }\n\n  const state = this.linking.getStateFromPath!(href, this.linking.config);\n\n  if (!state) {\n    console.error(\n      \"Could not generate a valid navigation state for the given path: \" + href\n    );\n    return;\n  }\n\n  const rootState = navigationRef.getRootState();\n\n  // Ensure simple operations are used when moving between siblings\n  // in the same navigator. This ensures that the state is not reset.\n  // TODO: We may need to apply this at a larger scale in the future.\n  if (isMovingToSiblingRoute(rootState, state)) {\n    // Can perform naive movements\n    const knownOwnerState = getQualifiedStateForTopOfTargetState(\n      rootState,\n      state\n    )!;\n    const nextRoute = findTopRouteForTarget(state);\n\n    if (knownOwnerState.type === \"tab\") {\n      if (event === \"REPLACE\") {\n        navigationRef.dispatch(\n          TabActions.jumpTo(nextRoute.name, nextRoute.params)\n        );\n      } else {\n        navigationRef.dispatch(\n          CommonActions.navigate(nextRoute.name, nextRoute.params)\n        );\n      }\n      return;\n    } else {\n      if (event === \"REPLACE\") {\n        navigationRef.dispatch(\n          StackActions.replace(nextRoute.name, nextRoute.params)\n        );\n      } else {\n        // NOTE: Not sure if we should pop or push here...\n        navigationRef.dispatch(\n          CommonActions.navigate(nextRoute.name, nextRoute.params)\n        );\n      }\n      return;\n    }\n  }\n\n  // TODO: Advanced movements across multiple navigators\n\n  const action = getActionFromState(state, this.linking.config);\n  if (action) {\n    // Here we have a navigation action to a nested screen, where we should ideally replace.\n    // This request can only be fulfilled if the target is an initial route.\n    // First, check if the action is fully initial routes.\n    // Then find the nearest mismatched route in the existing state.\n    // Finally, use the correct navigator-based action to replace the nested screens.\n    // NOTE(EvanBacon): A future version of this will involve splitting the navigation request so we replace as much as possible, then push the remaining screens to fulfill the request.\n    if (event === \"REPLACE\" && isAbsoluteInitialRoute(action)) {\n      const earliest = getEarliestMismatchedRoute(rootState, action.payload);\n      if (earliest) {\n        if (earliest.type === \"stack\") {\n          navigationRef.dispatch(\n            StackActions.replace(earliest.name, earliest.params)\n          );\n        } else {\n          navigationRef.dispatch(\n            TabActions.jumpTo(earliest.name, earliest.params)\n          );\n        }\n        return;\n      } else {\n        // This should never happen because moving to the same route would be handled earlier\n        // in the sibling operations.\n      }\n    }\n\n    // Ignore the replace event here since replace across\n    // navigators is not supported.\n    navigationRef.dispatch(action);\n  } else {\n    navigationRef.reset(state);\n  }\n}\n\n/** @returns `true` if the action is moving to the first screen of all the navigators in the action. */\nexport function isAbsoluteInitialRoute(\n  action: ReturnType<typeof getActionFromState>\n): action is NavigateAction {\n  if (action?.type !== \"NAVIGATE\") {\n    return false;\n  }\n\n  let next = action.payload.params;\n  // iterate all child screens and bail out if any are not initial.\n  while (next) {\n    if (!isNavigationState(next)) {\n      // Not sure when this would happen\n      return false;\n    }\n    if (next.initial === true) {\n      next = next.params;\n      // return true;\n    } else if (next.initial === false) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\ntype NavStateParams = {\n  params?: NavStateParams;\n  path: string;\n  initial: boolean;\n  screen: string;\n  state: unknown;\n};\n\nfunction isNavigationState(obj: any): obj is NavStateParams {\n  return \"initial\" in obj;\n}\n"],"mappings":"AAAA,SACEA,aAAa,EACbC,kBAAkB,EAClBC,YAAY,QACP,wBAAwB;AAC/B,SAASC,UAAU,QAAQ,0BAA0B;AACrD,OAAO,KAAKC,OAAO,MAAM,cAAc;AAEvC,SAAeC,WAAW;AAC1B,SAASC,OAAO;AAChB,SAEEC,qBAAqB,EACrBC,0BAA0B,EAC1BC,oCAAoC,EACpCC,sBAAsB;AAExB,SAASC,oBAAoB;AAG7B,SAASC,aAAaA,CAACC,KAAkB,EAAE;EACzC,IAAI,CAACA,KAAK,CAACC,OAAO,IAAI,CAACD,KAAK,CAACE,aAAa,CAACC,OAAO,EAAE;IAClD,MAAM,IAAIC,KAAK,CACb,gKACF,CAAC;EACH;AACF;AAEA,OAAO,SAASC,IAAIA,CAAoBC,GAAS,EAAE;EACjD,OAAO,IAAI,CAACC,MAAM,CAACf,WAAW,CAACc,GAAG,CAAC,CAAC;AACtC;AAEA,OAAO,SAASE,OAAOA,CAAoBF,GAAS,EAAE;EACpD,OAAO,IAAI,CAACC,MAAM,CAACf,WAAW,CAACc,GAAG,CAAC,EAAE,SAAS,CAAC;AACjD;AAEA,OAAO,SAASG,MAAMA,CAAA,EAAoB;EAAA,IAAAC,mBAAA,EAAAC,qBAAA;EACxCZ,aAAa,CAAC,IAAI,CAAC;EACnB,CAAAW,mBAAA,OAAI,CAACR,aAAa,sBAAAS,qBAAA,GAAlBD,mBAAA,CAAoBP,OAAO,qBAA3BQ,qBAAA,CAA6BF,MAAM,CAAC,CAAC;AACvC;AAEA,OAAO,SAASG,SAASA,CAAA,EAA6B;EAAA,IAAAC,sBAAA,EAAAC,oBAAA,EAAAC,qBAAA;EACpDhB,aAAa,CAAC,IAAI,CAAC;EACnB,QAAAc,sBAAA,IAAAC,oBAAA,GAAO,IAAI,CAACZ,aAAa,sBAAAa,qBAAA,GAAlBD,oBAAA,CAAoBX,OAAO,qBAA3BY,qBAAA,CAA6BH,SAAS,CAAC,CAAC,YAAAC,sBAAA,GAAI,KAAK;AAC1D;AAEA,OAAO,SAASG,SAASA,CAAA,EAGvB;EAAA,IAAAC,oBAAA,EAAAC,qBAAA;EAAA,IADAC,MAAuC,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC,CAAC;EAE5CrB,aAAa,CAAC,IAAI,CAAC;EACnB,OAAO,EAAAkB,oBAAA,GAAC,IAAI,CAACf,aAAa,sBAAAgB,qBAAA,GAAlBD,oBAAA,CAAoBd,OAAO,qBAA3Be,qBAAA,CAA6BF,SAAS,CAAAO,IAAA,CAAAL,qBAAA,GAASC,MAAM,CAAC;AAChE;AAEA,OAAO,SAASZ,MAAMA,CAAoBiB,IAAY,EAAEC,KAAc,EAAE;EACtE,IAAI3B,oBAAoB,CAAC0B,IAAI,CAAC,EAAE;IAC9BjC,OAAO,CAACmC,OAAO,CAACF,IAAI,CAAC;IACrB;EACF;EAEAzB,aAAa,CAAC,IAAI,CAAC;EACnB,IAAMG,aAAa,GAAG,IAAI,CAACA,aAAa,CAACC,OAAO;EAEhD,IAAID,aAAa,IAAI,IAAI,EAAE;IACzB,MAAM,IAAIE,KAAK,CACb,kFACF,CAAC;EACH;EAEA,IAAI,CAAC,IAAI,CAACuB,OAAO,EAAE;IACjB,MAAM,IAAIvB,KAAK,CAAC,uDAAuD,CAAC;EAC1E;EAEA,IAAIoB,IAAI,KAAK,IAAI,IAAIA,IAAI,KAAK,KAAK,EAAE;IACnCtB,aAAa,CAACO,MAAM,CAAC,CAAC;IACtB;EACF;EAEA,IAAIe,IAAI,CAACI,UAAU,CAAC,GAAG,CAAC,EAAE;IAAA,IAAAC,qBAAA,EAAAC,sBAAA,EAAAC,aAAA;IACxB,IAAIC,IAAI,IAAAH,qBAAA,IAAAC,sBAAA,GACN,CAAAC,aAAA,OAAI,CAACJ,OAAO,EAACM,gBAAgB,qBAA7BH,sBAAA,CAAAI,IAAA,CAAAH,aAAA,EAAgC7B,aAAa,CAACiC,YAAY,CAAC,CAAC,EAAE;MAC5DC,OAAO,EAAE,EAAE;MACXC,cAAc,EAAE;IAClB,CAAC,CAAC,YAAAR,qBAAA,GAAI,EAAE;IAEV,IAAIG,IAAI,IAAI,CAACA,IAAI,CAACM,QAAQ,CAAC,GAAG,CAAC,EAAE;MAC/BN,IAAI,IAAI,KAAK;IACf;IACAR,IAAI,GAAG/B,OAAO,CAACuC,IAAI,EAAER,IAAI,CAAC;EAC5B;EAEA,IAAMe,KAAK,GAAG,IAAI,CAACZ,OAAO,CAACa,gBAAgB,CAAEhB,IAAI,EAAE,IAAI,CAACG,OAAO,CAACc,MAAM,CAAC;EAEvE,IAAI,CAACF,KAAK,EAAE;IACVG,OAAO,CAACC,KAAK,CACX,kEAAkE,GAAGnB,IACvE,CAAC;IACD;EACF;EAEA,IAAMoB,SAAS,GAAG1C,aAAa,CAACiC,YAAY,CAAC,CAAC;EAK9C,IAAItC,sBAAsB,CAAC+C,SAAS,EAAEL,KAAK,CAAC,EAAE;IAE5C,IAAMM,eAAe,GAAGjD,oCAAoC,CAC1DgD,SAAS,EACTL,KACF,CAAE;IACF,IAAMO,SAAS,GAAGpD,qBAAqB,CAAC6C,KAAK,CAAC;IAE9C,IAAIM,eAAe,CAACE,IAAI,KAAK,KAAK,EAAE;MAClC,IAAItB,KAAK,KAAK,SAAS,EAAE;QACvBvB,aAAa,CAAC8C,QAAQ,CACpB1D,UAAU,CAAC2D,MAAM,CAACH,SAAS,CAACI,IAAI,EAAEJ,SAAS,CAAC3B,MAAM,CACpD,CAAC;MACH,CAAC,MAAM;QACLjB,aAAa,CAAC8C,QAAQ,CACpB7D,aAAa,CAACgE,QAAQ,CAACL,SAAS,CAACI,IAAI,EAAEJ,SAAS,CAAC3B,MAAM,CACzD,CAAC;MACH;MACA;IACF,CAAC,MAAM;MACL,IAAIM,KAAK,KAAK,SAAS,EAAE;QACvBvB,aAAa,CAAC8C,QAAQ,CACpB3D,YAAY,CAACmB,OAAO,CAACsC,SAAS,CAACI,IAAI,EAAEJ,SAAS,CAAC3B,MAAM,CACvD,CAAC;MACH,CAAC,MAAM;QAELjB,aAAa,CAAC8C,QAAQ,CACpB7D,aAAa,CAACgE,QAAQ,CAACL,SAAS,CAACI,IAAI,EAAEJ,SAAS,CAAC3B,MAAM,CACzD,CAAC;MACH;MACA;IACF;EACF;EAIA,IAAMiC,MAAM,GAAGhE,kBAAkB,CAACmD,KAAK,EAAE,IAAI,CAACZ,OAAO,CAACc,MAAM,CAAC;EAC7D,IAAIW,MAAM,EAAE;IAOV,IAAI3B,KAAK,KAAK,SAAS,IAAI4B,sBAAsB,CAACD,MAAM,CAAC,EAAE;MACzD,IAAME,QAAQ,GAAG3D,0BAA0B,CAACiD,SAAS,EAAEQ,MAAM,CAACG,OAAO,CAAC;MACtE,IAAID,QAAQ,EAAE;QACZ,IAAIA,QAAQ,CAACP,IAAI,KAAK,OAAO,EAAE;UAC7B7C,aAAa,CAAC8C,QAAQ,CACpB3D,YAAY,CAACmB,OAAO,CAAC8C,QAAQ,CAACJ,IAAI,EAAEI,QAAQ,CAACnC,MAAM,CACrD,CAAC;QACH,CAAC,MAAM;UACLjB,aAAa,CAAC8C,QAAQ,CACpB1D,UAAU,CAAC2D,MAAM,CAACK,QAAQ,CAACJ,IAAI,EAAEI,QAAQ,CAACnC,MAAM,CAClD,CAAC;QACH;QACA;MACF,CAAC,MAAM,CAGP;IACF;IAIAjB,aAAa,CAAC8C,QAAQ,CAACI,MAAM,CAAC;EAChC,CAAC,MAAM;IACLlD,aAAa,CAACsD,KAAK,CAACjB,KAAK,CAAC;EAC5B;AACF;AAGA,OAAO,SAASc,sBAAsBA,CACpCD,MAA6C,EACnB;EAC1B,IAAI,CAAAA,MAAM,oBAANA,MAAM,CAAEL,IAAI,MAAK,UAAU,EAAE;IAC/B,OAAO,KAAK;EACd;EAEA,IAAIU,IAAI,GAAGL,MAAM,CAACG,OAAO,CAACpC,MAAM;EAEhC,OAAOsC,IAAI,EAAE;IACX,IAAI,CAACC,iBAAiB,CAACD,IAAI,CAAC,EAAE;MAE5B,OAAO,KAAK;IACd;IACA,IAAIA,IAAI,CAACE,OAAO,KAAK,IAAI,EAAE;MACzBF,IAAI,GAAGA,IAAI,CAACtC,MAAM;IAEpB,CAAC,MAAM,IAAIsC,IAAI,CAACE,OAAO,KAAK,KAAK,EAAE;MACjC,OAAO,KAAK;IACd;EACF;EAEA,OAAO,IAAI;AACb;AAUA,SAASD,iBAAiBA,CAACE,GAAQ,EAAyB;EAC1D,OAAO,SAAS,IAAIA,GAAG;AACzB"},"metadata":{},"sourceType":"module","externalDependencies":[]}